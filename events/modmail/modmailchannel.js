let ticket = 0;
// Le nombre de tickets cr√©√©s
const EventBase = require('../../utils/assets/EventBase');
module.exports = class ModMailChannelEvent extends EventBase {
    constructor() {
        super('modmailchannel');
    }
    async run(client, message) {
        if (message.author.bot) return;
        let guild = client.guilds.cache.get(process.env.GUILD_ID);
        // On prend en compte le serveur


        let channel = client.channels.cache.get(process.env.CHANNEL_STAFF)
        // OU message.guild.channels.cache.find(channel => channel.name === "LE NOM DU CHANNEL")


        // On prend en compte le channel des staffs (dans lequel les messages seront envoye√©s)
        let role = guild.roles.cache.get(process.env.ROLE_STAFF)
        // OU message.guild.roles.cache.find(role => role.name === "NOM DU ROLE");
        // Le r√¥le staff que la personne doit avoir pour accepter/refuser

        if (this.time.has(message.author.id)) return message.channel.send("Tu as ferm√© un ticket trop r√©cemment.");
        // V√©rification que l'utilisateur n'as pas eu de ticket r√©cemment
        if (!this.seen.has(message.author.id)) {
            // V√©rification que l'utilisateur n'a pas de ticket ouvert en en cours
            this.seen.set(message.author.id, message.channel.id)
            // Ajout de l'utilisateur dans la map (l'utilisateur a un ticket)
            message.channel.send("Votre ticket a bien √©t√© pris en compte.")
            // Message de confirmation pour l'utilisateur
            let messagetostaff = await channel.send(message.content);
            // Envoie du message de l'utilisateur dans le channel staff
            await messagetostaff.react("‚ùå");
            // R√©action "annuler" sur la demande de ticket
            await messagetostaff.react("üü¢");
            // R√©action "accepter" sur la demande de ticket
            try {
                let filtre = (reaction, user) => ["‚ùå", "üü¢"].includes(reaction.emoji.name) && !user.bot && guild.member(user.id).roles.cache.has(role);
                // V√©rification que la r√©action est ‚ùå ou üü¢ et que l'utilisateur ne soit pas le bot, et que l'utilisateur ait le r√¥le staff
                let reactionCollection = await messagetostaff.awaitReactions(filtre, {
                    max: 1,
                    time: 86400000
                });
                // Collection de la premi√®re r√©action ajout√©e
                let choix = reactionCollection.get("‚ùå") || reactionCollection.get("üü¢");
                // La r√©action qui a √©t√© ajout√©e, soit ‚ùå ou üü¢;
                if (choix.emoji.name === "‚ùå") {
                    // Si le staff refuse
                    message.author.send("Votre ticket a √©t√© refus√©.");
                    // Message de refus envoy√© √† l'utilisateur
                    this.seen.delete(message.author.id)
                    // Suppression de l'utilisateur dans la map des tickets ouverts
                    time.set(message.author.id, message.channel);
                    // Ajout de l'utilisateur dans la map des tickets r√©cents
                    setTimeout(() => {
                        // D√©lai pour que l'utilisateur ne puisse pas ouvrir des tickets toutes les secondes
                        time.delete(message.author.id);
                        // Suppresion de l'utilisateur dans la map des tickets r√©cents
                    }, 100000)
                    // Apr√®s 100 secondes
                } else {
                    // Si le staff a valid√©
                    message.author.send("Votre ticket a √©t√© accept√©.");
                    // Message d'acceptation du ticket envoy√© √† l'utilisateur
                    ticket++
                    // Le nombre de ticket augmente
                    let newchannel = await channel.guild.channels.create(`ticket-${ticket}`, {
                        // Cr√©ation du channel avec ce nom "ticket-{numero}"
                        type: "text",
                        // Type du channel pour que ce soit un channel textuel
                        permissionOverwrites: [
                            // Les permissions du channel
                            {
                                id: message.author.id,
                                // L'utilisateur qui a demand√© le ticket
                                allow: ["SEND_MESSAGES", "VIEW_CHANNEL", "ADD_REACTIONS"]
                                // Il puisse voir le channel, envoyer des messages, et ajouter des r√©actions
                            },
                            {
                                id: channel.guild.id,
                                // @everyone
                                deny: ["VIEW_CHANNEL"]
                                // Interdiction de voir le channel
                            },
                            {
                                id: role.id,
                                // Le r√¥le staff
                                allow: ["SEND_MESSAGE", "VIEW_CHANNEL", "ADD_REACTIONS", "MANAGE_MESSAGES"]
                                // Il puisse voir le channel, envoyer des messages et g√©rer les messages
                            }
                        ]
                    })
                    newchannel.send(`Le ticket de ${user.username} a √©t√© accept√©. Pour la raison **${message.content}**`);
                    // Message de confirmation de la cr√©ation du channel dans le nouveau channel
                    collectors(newchannel, message);
                    // D√©but de la collection des messages entre les MP et du nouveau channel
                }
            } catch (err) {
                console.log(err)
                // Console.log s'il y a une erreur
                message.author.send("Votre requ√™te n'a pas √©t√© convaincante.");
                // Envoie du message que le staff n'a pas pu ajouter de r√©action dans le temps imparti
                this.seen.delete(message.author.id);
                // Suppression de l'utilisateur dans la map des tickets ouverts
                this.time.add(message.author.id, message.channel);
                // Ajout de l'utilisateur dans la map des tickets r√©cents
                setTimeout(() => {
                    // D√©lai pour que l'utilisateur ne puisse pas cr√©er de ticket dans les secondes qui suivent
                    this.time.delete(message.author.id);
                    // Suppression de l'utilisateur dans les tickets r√©cents
                }, 10000);
                // Apr√®s 10 secondes
            }
        }
        /**
         * Gestion des collectors.
         * @param {Object} message - Le message qui a √©t√© envoy√© en MP
         * @param {Object} channel - Le channel staff.
         */
        function collectors(channel, message) {
            // D√©claration de la fonction des collectors
            let filterStaff = m => m.channel.id === channel.id && !m.author.bot && m.member.roles.cache.has(role);
            // Filtre des messages dans le channel staff, le channel doit √™tre le channel staff et l'auteur ne doit pas √™tre le bot
            let channelCollector = channel.createMessageCollector(filterStaff);
            // D√©claration du collector dans le channel staff
            let filterDM = m => m.channel.id === message.channel.id && m.author.id === message.author.id;
            // Filtre des messages dans les MP, le channel doit √™tre le MP de l'utilisateur, et l'auteur doit √™tre l'utilisateur
            let DMCollector = message.channel.createMessageCollector(filterDM);
            // D√©claraction du collector dans les MP
            DMCollector.on("collect", m => {
                // D√©but de la collection des messages en MP
                if (m.attachments.size !== 0) {
                    // V√©rification que le message contient des fichiers
                    getImages(m.attachments, channel)
                    // Si oui, il ex√©cute la fonction "getImages" d√©clar√©e en bas
                }
                channel.send(m.content);
                // Envoie le contenu du message de l'utilisateur dans le channel des staffs
            })
            channelCollector.on("collect", m => {
                // D√©but de la collection des messages des staffs
                if (m.content === "!fermer") {
                    // Si le message est la commande "!fermer"
                    message.channel.send("Votre ticket a √©t√© ferm√© par le staff.")
                    // Envoie du message de confirmation dans les MP de l'utilisateur
                    m.channel.send("Le ticket a bien √©t√© ferm√©");
                    // Envoie du message de confirmation dans le channel Staff
                    this.seen.delete(message.author.id)
                    // Suppression de l'utilisateur dans la Map des tickets ouverts
                    this.time.set(message.author.id, message.channel)
                    // Ajout de l'utilisateur dans la Map des tickets r√©cents
                    setTimeout(() => {
                        // D√©lai pour que l'utilisateur ne puisse pas cr√©er de ticket dans les secondes qui suivent
                        this.time.delete(message.author.id);
                        // Suppression de l'utilisateur dans les tickets r√©cents
                    }, 10000);
                    // Apr√®s 10 secondes
                    DMCollector.stop();
                    // Arr√™t du collector dans les MP(aucun message ne sera connect√© et envoy√©)
                    channelCollector.stop();
                    // Arr√™t du collector dans le channel staff(aucun message ne sera connect√© et envoy√©)
                } else {
                    if (m.attachments.size !== 0) {
                        // V√©rification que le message contient des fichiers
                        getImages(m.attachments, channel)
                        // Si oui, il ex√©cute la fonction "getImages" d√©clar√©e en bas
                    }
                    message.channel.send(m.content);
                    // Envoie le contenu du message envoy√© par le staff dans les MP de l'utilisateur
                }

            })
        }
        /**
         * Gestion des images.
         * @param {Object} channel - Le channel en question (staff ou MP)
         * @param {Array} fichiers - Tableau des fichiers envoy√©s.
         */
        function getImages(fichiers, channel) {
            // D√©claraction de la fonction "getImages" qui prend en param√®tres, les fichiers du message, et le channel o√π ils ont √©t√© envoy√©
            const validation = /^.*(gif|png|jpg|jpeg)$/g;
            // Expression RegEx qui filtre les fichiers pour que √ßa ne soit que des images, et des gifs
            let images = fichiers.array().filter(image => validation.test(image.url)).map(image => image.url);
            // Cr√©e un tableau avec les liens des images, apr√®s filtrer pour que ce ne soit que des images
            channel.send({
                files: images
            });
            // Envoie les images dans le channel
        }
    }
};